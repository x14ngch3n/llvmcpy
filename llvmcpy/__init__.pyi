from collections.abc import Generator

from _typeshed import Incomplete

# from cffi import FFI as FFI

# ffi: Incomplete

class LLVMException(Exception): ...

# libLLVMAnalysis: Incomplete
# libLLVMSparcCodeGen: Incomplete
# libLLVMNVPTXCodeGen: Incomplete
# libLLVMX86CodeGen: Incomplete
# libLLVMSparcInfo: Incomplete
# libLLVMHexagonDesc: Incomplete
# libLLVMXCoreCodeGen: Incomplete
# libLLVMCodeGen: Incomplete
# libLLVMExecutionEngine: Incomplete
# libLLVMAArch64Info: Incomplete
# libLLVMMC: Incomplete
# libLLVMInstCombine: Incomplete
# libLLVMHexagonDisassembler: Incomplete
# libLLVMSystemZAsmParser: Incomplete
# libLLVMSparcAsmParser: Incomplete
# libLLVMSystemZDesc: Incomplete
# libLLVMVectorize: Incomplete
# libLLVMipo: Incomplete
# libLLVMMipsInfo: Incomplete
# libLLVMR600Info: Incomplete
# libLLVMSelectionDAG: Incomplete
# libLLVMObjCARCOpts: Incomplete
# libLLVMMipsAsmPrinter: Incomplete
# libLLVMAArch64CodeGen: Incomplete
# libLLVMPowerPCInfo: Incomplete
# libLLVMTransformUtils: Incomplete
# libLLVMX86AsmPrinter: Incomplete
# libLLVMXCoreInfo: Incomplete
# libLLVMAArch64AsmPrinter: Incomplete
# libLLVMNVPTXDesc: Incomplete
# libLLVMTarget: Incomplete
# libLLVMBitReader: Incomplete
# libLLVMMipsAsmParser: Incomplete
# libLLVMARMDesc: Incomplete
# libLLVMARMInfo: Incomplete
# libLLVMX86Disassembler: Incomplete
# libLLVMCppBackendCodeGen: Incomplete
# libLLVMAArch64Utils: Incomplete
# libLLVMIRReader: Incomplete
# libLLVMNVPTXAsmPrinter: Incomplete
# libLLVMLineEditor: Incomplete
# libLLVMInstrumentation: Incomplete
# libLLVMARMAsmParser: Incomplete
# libLLVMAsmPrinter: Incomplete
# libLLVMPowerPCDisassembler: Incomplete
# libLLVMSupport: Incomplete
# libLLVMXCoreDesc: Incomplete
# libLLVMR600Desc: Incomplete
# libLLVMSystemZInfo: Incomplete
# libLLVMHexagonCodeGen: Incomplete
# libLLVMSparcAsmPrinter: Incomplete
# libLLVMMCParser: Incomplete
# libLLVMProfileData: Incomplete
# libLLVMMSP430AsmPrinter: Incomplete
# libLLVMAArch64Disassembler: Incomplete
# libLLVMAsmParser: Incomplete
# libLLVMXCoreDisassembler: Incomplete
# libLLVMMCJIT: Incomplete
# libLLVMR600AsmPrinter: Incomplete
# libLLVMCppBackendInfo: Incomplete
# libLLVMXCoreAsmPrinter: Incomplete
# libLLVMSystemZDisassembler: Incomplete
# libLLVMSparcDisassembler: Incomplete
# libLLVMScalarOpts: Incomplete
# libLLVMARMAsmPrinter: Incomplete
# libLLVMX86Utils: Incomplete
# libLLVMRuntimeDyld: Incomplete
# libLLVMHexagonInfo: Incomplete
# libLLVMAArch64AsmParser: Incomplete
# libLLVMDebugInfo: Incomplete
# libLLVMR600AsmParser: Incomplete
# libLLVMPowerPCDesc: Incomplete
# libLLVMSparcDesc: Incomplete
# libLLVMMSP430CodeGen: Incomplete
# libLLVMAArch64Desc: Incomplete
# libLLVMMipsDisassembler: Incomplete
# libLLVMSystemZAsmPrinter: Incomplete
# libLLVMX86AsmParser: Incomplete
# libLLVMCore: Incomplete
# libLLVMObject: Incomplete
# libLLVMLinker: Incomplete
# libLLVMX86Info: Incomplete
# libLLVMPowerPCCodeGen: Incomplete
# libLLVMipa: Incomplete
# libLLVMTableGen: Incomplete
# libLLVMX86Desc: Incomplete
# libLLVMMipsDesc: Incomplete
# libLLVMInterpreter: Incomplete
# libLLVMOption: Incomplete
# libLLVMR600CodeGen: Incomplete
# libLLVMLTO: Incomplete
# libLLVMMSP430Info: Incomplete
# libLLVMSystemZCodeGen: Incomplete
# libLLVMMipsCodeGen: Incomplete
# libLLVMBitWriter: Incomplete
# libLLVMMSP430Desc: Incomplete
# libLLVMARMCodeGen: Incomplete
# libLLVMMCDisassembler: Incomplete
# libLLVMARMDisassembler: Incomplete
# libLLVMPowerPCAsmParser: Incomplete
# libLLVMPowerPCAsmPrinter: Incomplete
# libLLVMNVPTXInfo: Incomplete

# class TargetData:
#     def __new__(cls, value=None): ...
#     ptr: Incomplete
#     def __init__(self, value=None) -> None: ...
#     def __hash__(self): ...
#     def __eq__(self, other): ...
#     def in_ptr(self): ...
#     def out_ptr(self): ...
#     def abi_alignment_of_type(self, arg0): ...
#     def abi_size_of_type(self, arg0): ...
#     def add(self, arg0): ...
#     def byte_order(self): ...
#     def call_frame_alignment_of_type(self, arg0): ...
#     def copy_string_rep_of(self): ...
#     def dispose(self): ...
#     def element_at_offset(self, arg0, arg1): ...
#     def int_ptr_type(self): ...
#     def int_ptr_type_for_as(self, arg0): ...
#     def offset_of_element(self, arg0, arg1): ...
#     def pointer_size(self): ...
#     def pointer_size_for_as(self, arg0): ...
#     def preferred_alignment_of_global(self, arg0): ...
#     def preferred_alignment_of_type(self, arg0): ...
#     def size_of_type_in_bits(self, arg0): ...
#     def store_size_of_type(self, arg0): ...

class LLVMModule:
    # def __new__(cls, value=None) -> LLVMModule: ...
    # ptr: Incomplete
    # def __init__(self, value=None) -> None: ...
    # def __hash__(self) -> int: ...
    # def __eq__(self, other) -> bool: ...
    # def in_ptr(self) -> Incomplete: ...
    # def out_ptr(self) -> Incomplete: ...
    def add_alias(
        self, value_type: LLVMType, aliasee: LLVMValue, name: str
    ) -> LLVMValue: ...
    def add_function(self, name: str, function_type: LLVMType) -> LLVMValue: ...
    def add_global(self, type_: LLVMType, name: str) -> LLVMValue: ...
    def add_global_in_address_space(
        self, type_: LLVMType, name: str, address_space: int
    ) -> LLVMValue: ...
    def add_named_metadata_operand(self, name: str, value: LLVMValue) -> None: ...
    def create_function_pass_manager_for(self) -> LLVMPassManager: ...
    def create_module_provider_for_existing(self) -> LLVMModuleProvider: ...
    def dispose(self) -> None: ...
    def dump(self) -> None: ...
    def get_data_layout(self) -> bytes: ...
    def get_first_function(self) -> LLVMFunction | None: ...
    def iter_functions(self) -> Generator[LLVMFunction, None, None]: ...
    def get_first_global(self) -> LLVMGlobalVariable | None: ...
    def iter_globals(self) -> Generator[LLVMGlobalVariable, None, None]: ...
    def get_last_function(self) -> LLVMFunction | None: ...
    def get_last_global(self) -> LLVMGlobalVariable | None: ...
    def get_context(self) -> LLVMContext: ...
    def get_named_function(self, name: str) -> LLVMFunction | None: ...
    def get_named_global(self, name: str) -> LLVMGlobalVariable | None: ...
    def get_named_metadata_num_operands(self, name: str) -> int: ...
    def get_named_metadata_operands(
        self, name: str, dest: list[LLVMValue] | LLVMValue
    ) -> None: ...
    def get_target(self) -> bytes: ...
    def get_type_by_name(self, name: str) -> LLVMType | None: ...
    def print_module_to_file(self, filename: str) -> None: ...
    def print_module_to_string(self) -> bytes: ...
    def set_data_layout(self, data_layout: str) -> None: ...
    def set_inline_asm(self, inline_asm: str) -> None: ...
    def set_target(self, target_triple: str) -> None: ...
    def verify(self, action: int) -> None: ...
    def clone(self) -> LLVMModule: ...
    def link_modules(self, src: LLVMModule, linker_mode: int) -> None: ...
    def write_bitcode_to_fd(
        self, fd: int, should_close: int, unbuffered: int
    ) -> int: ...
    def write_bitcode_to_file(self, path: str) -> int: ...
    def write_bitcode_to_file_handle(self, handle: int) -> int: ...
    def write_bitcode_to_memory_buffer(self) -> LLVMMemoryBuffer: ...

    # Properties
    data_layout: bytes
    first_function: LLVMFunction | None
    first_global: LLVMGlobalVariable | None
    last_function: LLVMFunction | None
    last_global: LLVMGlobalVariable | None
    context: LLVMContext
    target: bytes
    inline_asm: str

# class TargetMachine:
#     def __new__(cls, value=None): ...
#     ptr: Incomplete
#     def __init__(self, value=None) -> None: ...
#     def __hash__(self): ...
#     def __eq__(self, other): ...
#     def in_ptr(self): ...
#     def out_ptr(self): ...
#     def add_analysis_passes(self, arg0): ...
#     def dispose(self): ...
#     def get_cpu(self): ...
#     def get_data(self): ...
#     def get_feature_string(self): ...
#     def get_target(self): ...
#     def get_triple(self): ...
#     def set_asm_verbosity(self, arg0): ...
#     def emit_to_file(self, arg0, arg1, arg2): ...
#     def emit_to_memory_buffer(self, arg0, arg1, arg2): ...
#     cpu: Incomplete
#     data: Incomplete
#     feature_string: Incomplete
#     target: Incomplete
#     triple: Incomplete
#     asm_verbosity: Incomplete

class LLVMFunction(LLVMValue):
    # Function-specific methods
    def count_basic_blocks(self) -> int: ...
    def append_basic_block(self, name: str) -> LLVMBasicBlock: ...
    def get_first_basic_block(self) -> LLVMBasicBlock | None: ...
    def get_last_basic_block(self) -> LLVMBasicBlock | None: ...
    def iter_basic_blocks(self) -> Generator[LLVMBasicBlock, None, None]: ...
    def get_basic_blocks(self, dest: list[LLVMBasicBlock]) -> None: ...
    def get_entry_basic_block(self) -> LLVMBasicBlock: ...

    # Parameter methods
    def count_params(self) -> int: ...
    def get_first_param(self) -> LLVMValue | None: ...
    def get_last_param(self) -> LLVMValue | None: ...
    def iter_params(self) -> Generator[LLVMValue, None, None]: ...
    def get_param(self, index: int) -> LLVMValue: ...
    def get_params(self, dest: list[LLVMValue]) -> None: ...
    def get_param_parent(self) -> LLVMFunction: ...

    # Function operations
    def delete_function(self) -> None: ...
    def add_function_attr(self, attr: int) -> None: ...
    def remove_function_attr(self, attr: int) -> None: ...
    def add_target_dependent_function_attr(self, name: str, value: str) -> None: ...
    def get_function_attr(self) -> int: ...
    def get_function_call_conv(self) -> int: ...
    def set_function_call_conv(self, call_conv: int) -> None: ...
    def get_gc(self) -> bytes: ...
    def set_gc(self, gc: str) -> None: ...
    def get_intrinsic_id(self) -> int: ...
    def verify_function(self, action: int) -> None: ...
    def view_function_cfg(self) -> None: ...
    def view_function_cfg_only(self) -> None: ...

    # Navigation methods for functions
    def get_next_function(self) -> LLVMFunction | None: ...
    def get_previous_function(self) -> LLVMFunction | None: ...

    # Properties
    entry_basic_block: LLVMBasicBlock
    first_basic_block: LLVMBasicBlock | None
    last_basic_block: LLVMBasicBlock | None
    first_param: LLVMValue | None
    last_param: LLVMValue | None
    next_function: LLVMFunction | None
    previous_function: LLVMFunction | None
    function_attr: int
    function_call_conv: int
    gc: bytes
    intrinsic_id: int

class LLVMInstruction(LLVMValue):
    # Instruction operations
    def instruction_clone(self) -> LLVMInstruction: ...
    def instruction_erase_from_parent(self) -> None: ...
    def get_instruction_opcode(self) -> int: ...
    def get_instruction_parent(self) -> LLVMBasicBlock: ...
    def get_instruction_call_conv(self) -> int: ...
    def set_instruction_call_conv(self, call_conv: int) -> None: ...
    def add_instr_attribute(self, index: int, attr: int) -> None: ...
    def remove_instr_attribute(self, index: int, attr: int) -> None: ...
    def set_instr_param_alignment(self, index: int, alignment: int) -> None: ...

    # Control flow instructions
    def add_case(self, on_val: LLVMValue, dest: LLVMBasicBlock) -> None: ...
    def add_clause(self, clause: LLVMValue) -> None: ...
    def add_destination(self, dest: LLVMBasicBlock) -> None: ...
    def get_condition(self) -> LLVMValue: ...
    def set_condition(self, condition: LLVMValue) -> None: ...
    def get_switch_default_dest(self) -> LLVMBasicBlock: ...
    def get_successor(self, index: int) -> LLVMBasicBlock: ...
    def set_successor(self, index: int, block: LLVMBasicBlock) -> None: ...
    def get_num_successors(self) -> int: ...

    # PHI node operations
    def add_incoming(
        self, values: list[LLVMValue], blocks: list[LLVMBasicBlock]
    ) -> None: ...
    def count_incoming(self) -> int: ...
    def get_incoming(self, index: int) -> LLVMValue: ...
    def get_incoming_block(self, index: int) -> LLVMBasicBlock: ...

    # Instruction properties
    def get_volatile(self) -> bool: ...
    def set_volatile(self, is_volatile: bool) -> None: ...
    def is_tail_call(self) -> bool: ...
    def set_tail_call(self, is_tail_call: bool) -> None: ...
    def set_cleanup(self, is_cleanup: bool) -> None: ...

    # Instruction type checking methods
    def is_a_addr_space_cast_inst(self) -> LLVMValue | None: ...
    def is_a_alloca_inst(self) -> LLVMValue | None: ...
    def is_a_binary_operator(self) -> LLVMValue | None: ...
    def is_a_bit_cast_inst(self) -> LLVMValue | None: ...
    def is_a_branch_inst(self) -> LLVMValue | None: ...
    def is_a_call_inst(self) -> LLVMValue | None: ...
    def is_a_cast_inst(self) -> LLVMValue | None: ...
    def is_a_cmp_inst(self) -> LLVMValue | None: ...
    def is_a_dbg_declare_inst(self) -> LLVMValue | None: ...
    def is_a_dbg_info_intrinsic(self) -> LLVMValue | None: ...
    def is_a_extract_element_inst(self) -> LLVMValue | None: ...
    def is_a_extract_value_inst(self) -> LLVMValue | None: ...
    def is_af_cmp_inst(self) -> LLVMValue | None: ...
    def is_afp_ext_inst(self) -> LLVMValue | None: ...
    def is_afp_to_si_inst(self) -> LLVMValue | None: ...
    def is_afp_to_ui_inst(self) -> LLVMValue | None: ...
    def is_afp_trunc_inst(self) -> LLVMValue | None: ...
    def is_a_get_element_ptr_inst(self) -> LLVMValue | None: ...
    def is_ai_cmp_inst(self) -> LLVMValue | None: ...
    def is_a_indirect_br_inst(self) -> LLVMValue | None: ...
    def is_a_insert_element_inst(self) -> LLVMValue | None: ...
    def is_a_insert_value_inst(self) -> LLVMValue | None: ...
    def is_a_instruction(self) -> LLVMValue | None: ...
    def is_a_int_to_ptr_inst(self) -> LLVMValue | None: ...
    def is_a_intrinsic_inst(self) -> LLVMValue | None: ...
    def is_a_invoke_inst(self) -> LLVMValue | None: ...
    def is_a_landing_pad_inst(self) -> LLVMValue | None: ...
    def is_a_load_inst(self) -> LLVMValue | None: ...
    def is_a_mem_cpy_inst(self) -> LLVMValue | None: ...
    def is_a_mem_intrinsic(self) -> LLVMValue | None: ...
    def is_a_mem_move_inst(self) -> LLVMValue | None: ...
    def is_a_mem_set_inst(self) -> LLVMValue | None: ...
    def is_aphi_node(self) -> LLVMValue | None: ...
    def is_a_ptr_to_int_inst(self) -> LLVMValue | None: ...
    def is_a_resume_inst(self) -> LLVMValue | None: ...
    def is_a_return_inst(self) -> LLVMValue | None: ...
    def is_as_ext_inst(self) -> LLVMValue | None: ...
    def is_asi_to_fp_inst(self) -> LLVMValue | None: ...
    def is_a_select_inst(self) -> LLVMValue | None: ...
    def is_a_shuffle_vector_inst(self) -> LLVMValue | None: ...
    def is_a_store_inst(self) -> LLVMValue | None: ...
    def is_a_switch_inst(self) -> LLVMValue | None: ...
    def is_a_terminator_inst(self) -> LLVMValue | None: ...
    def is_a_trunc_inst(self) -> LLVMValue | None: ...
    def is_aui_to_fp_inst(self) -> LLVMValue | None: ...
    def is_a_unary_instruction(self) -> LLVMValue | None: ...
    def is_a_unreachable_inst(self) -> LLVMValue | None: ...
    def is_ava_arg_inst(self) -> LLVMValue | None: ...
    def is_az_ext_inst(self) -> LLVMValue | None: ...

    # Properties
    instruction_opcode: int
    instruction_parent: LLVMBasicBlock
    instruction_call_conv: int
    condition: LLVMValue
    switch_default_dest: LLVMBasicBlock
    volatile: bool

class LLVMGlobalVariable(LLVMValue):
    # Global variable specific methods
    def delete_global(self) -> None: ...
    def get_alignment(self) -> int: ...
    def set_alignment(self, alignment: int) -> None: ...
    def get_dll_storage_class(self) -> int: ...
    def set_dll_storage_class(self, storage_class: int) -> None: ...
    def get_initializer(self) -> LLVMValue | None: ...
    def set_initializer(self, constant: LLVMValue) -> None: ...
    def get_linkage(self) -> int: ...
    def set_linkage(self, linkage: int) -> None: ...
    def get_visibility(self) -> int: ...
    def set_visibility(self, visibility: int) -> None: ...
    def get_section(self) -> bytes: ...
    def is_externally_initialized(self) -> bool: ...
    def set_externally_initialized(self, is_external: bool) -> None: ...
    def is_global_constant(self) -> bool: ...
    def set_global_constant(self, is_constant: bool) -> None: ...
    def is_thread_local(self) -> bool: ...
    def set_thread_local(self, is_thread_local: bool) -> None: ...
    def get_thread_local_mode(self) -> int: ...
    def set_thread_local_mode(self, mode: int) -> None: ...

    # Navigation methods for global variables
    def get_next_global(self) -> LLVMGlobalVariable | None: ...
    def get_previous_global(self) -> LLVMGlobalVariable | None: ...
    def get_global_parent(self) -> LLVMModule: ...

    # Properties
    alignment: int
    dll_storage_class: int
    initializer: LLVMValue | None
    linkage: int
    visibility: int
    section: bytes
    externally_initialized: bool
    global_constant: bool
    thread_local: bool
    thread_local_mode: int
    next_global: LLVMGlobalVariable | None
    previous_global: LLVMGlobalVariable | None

class LLVMValue:
    # def __new__(cls, value=None) -> LLVMValue: ...
    # ptr: Incomplete
    # def __init__(self, value=None) -> None: ...
    # def __hash__(self) -> int: ...
    # def __eq__(self, other) -> bool: ...
    # def in_ptr(self) -> Incomplete: ...
    # def out_ptr(self) -> Incomplete: ...

    # Global/value attribute methods
    def add_attribute(self, attr: int) -> None: ...
    def remove_attribute(self, attr: int) -> None: ...
    def get_attribute(self) -> int: ...

    # Value operations and properties
    def dump(self) -> None: ...
    def print_value_to_string(self) -> bytes: ...
    def replace_all_uses_with(self, new_val: LLVMValue) -> None: ...
    def type_of(self) -> LLVMType: ...
    def get_name(self) -> bytes: ...
    def set_name(self, name: str) -> None: ...

    # String/data extraction
    def get_as_string(self, encoding: str = "utf-8") -> str: ...
    def get_md_string(self, encoding: str = "utf-8") -> str: ...

    # Metadata operations
    def has_metadata(self) -> bool: ...
    def get_metadata(self, kind_id: int) -> LLVMValue | None: ...
    def set_metadata(self, kind_id: int, node: LLVMValue) -> None: ...
    def get_md_node_num_operands(self) -> int: ...
    def get_md_node_operands(self, dest: list[LLVMValue]) -> None: ...

    # Use iteration
    def get_first_use(self) -> LLVMUse | None: ...
    def iter_uses(self) -> Generator[LLVMUse, None, None]: ...

    # Operand access
    def get_num_operands(self) -> int: ...
    def get_operand(self, index: int) -> LLVMValue: ...
    def set_operand(self, index: int, value: LLVMValue) -> None: ...
    def get_operand_use(self, index: int) -> LLVMUse: ...

    # Address handling
    def has_unnamed_addr(self) -> bool: ...
    def set_unnamed_addr(self, has_unnamed_addr: bool) -> None: ...

    # BasicBlock operations
    def as_basic_block(self) -> LLVMBasicBlock: ...
    def is_basic_block(self) -> bool: ...
    def block_address(self, basic_block: LLVMBasicBlock) -> LLVMValue: ...

    # Constant operations (these return new constant values)
    def const_a_shr(self, rhs: LLVMValue) -> LLVMValue: ...
    def const_add(self, rhs: LLVMValue) -> LLVMValue: ...
    def const_addr_space_cast(self, to_type: LLVMType) -> LLVMValue: ...
    def const_and(self, rhs: LLVMValue) -> LLVMValue: ...
    def const_bit_cast(self, to_type: LLVMType) -> LLVMValue: ...
    def const_exact_s_div(self, rhs: LLVMValue) -> LLVMValue: ...
    def const_extract_element(self, index: LLVMValue) -> LLVMValue: ...
    def const_extract(self, indices: list[int]) -> LLVMValue: ...
    def const_f_add(self, rhs: LLVMValue) -> LLVMValue: ...
    def const_f_div(self, rhs: LLVMValue) -> LLVMValue: ...
    def const_f_mul(self, rhs: LLVMValue) -> LLVMValue: ...
    def const_f_neg(self) -> LLVMValue: ...
    def const_fp_cast(self, to_type: LLVMType) -> LLVMValue: ...
    def const_fp_ext(self, to_type: LLVMType) -> LLVMValue: ...
    def const_fp_to_si(self, to_type: LLVMType) -> LLVMValue: ...
    def const_fp_to_ui(self, to_type: LLVMType) -> LLVMValue: ...
    def const_fp_trunc(self, to_type: LLVMType) -> LLVMValue: ...
    def const_f_rem(self, rhs: LLVMValue) -> LLVMValue: ...
    def const_f_sub(self, rhs: LLVMValue) -> LLVMValue: ...
    def const_gep(self, indices: list[LLVMValue]) -> LLVMValue: ...
    def const_in_bounds_gep(self, indices: list[LLVMValue]) -> LLVMValue: ...
    def const_insert_element(
        self, element: LLVMValue, index: LLVMValue
    ) -> LLVMValue: ...
    def const_insert(self, element: LLVMValue, indices: list[int]) -> LLVMValue: ...
    def const_int_cast(self, to_type: LLVMType, is_signed: bool) -> LLVMValue: ...
    def const_int_get_s_ext(self) -> int: ...
    def const_int_get_z_ext(self) -> int: ...
    def const_int_to_ptr(self, to_type: LLVMType) -> LLVMValue: ...
    def const_l_shr(self, rhs: LLVMValue) -> LLVMValue: ...
    def const_mul(self, rhs: LLVMValue) -> LLVMValue: ...
    def const_nsw_add(self, rhs: LLVMValue) -> LLVMValue: ...
    def const_nsw_mul(self, rhs: LLVMValue) -> LLVMValue: ...
    def const_nsw_neg(self) -> LLVMValue: ...
    def const_nsw_sub(self, rhs: LLVMValue) -> LLVMValue: ...
    def const_nuw_add(self, rhs: LLVMValue) -> LLVMValue: ...
    def const_nuw_mul(self, rhs: LLVMValue) -> LLVMValue: ...
    def const_nuw_neg(self) -> LLVMValue: ...
    def const_nuw_sub(self, rhs: LLVMValue) -> LLVMValue: ...
    def const_neg(self) -> LLVMValue: ...
    def const_not(self) -> LLVMValue: ...
    def const_or(self, rhs: LLVMValue) -> LLVMValue: ...
    def const_pointer_cast(self, to_type: LLVMType) -> LLVMValue: ...
    def const_ptr_to_int(self, to_type: LLVMType) -> LLVMValue: ...
    def const_real_get_double(self, loses_info: bool) -> float: ...
    def const_s_div(self, rhs: LLVMValue) -> LLVMValue: ...
    def const_s_ext(self, to_type: LLVMType) -> LLVMValue: ...
    def const_s_ext_or_bit_cast(self, to_type: LLVMType) -> LLVMValue: ...
    def const_si_to_fp(self, to_type: LLVMType) -> LLVMValue: ...
    def const_s_rem(self, rhs: LLVMValue) -> LLVMValue: ...
    def const_select(self, if_true: LLVMValue, if_false: LLVMValue) -> LLVMValue: ...
    def const_shl(self, rhs: LLVMValue) -> LLVMValue: ...
    def const_shuffle_vector(
        self, vector_b: LLVMValue, mask: LLVMValue
    ) -> LLVMValue: ...
    def const_sub(self, rhs: LLVMValue) -> LLVMValue: ...
    def const_trunc(self, to_type: LLVMType) -> LLVMValue: ...
    def const_trunc_or_bit_cast(self, to_type: LLVMType) -> LLVMValue: ...
    def const_u_div(self, rhs: LLVMValue) -> LLVMValue: ...
    def const_ui_to_fp(self, to_type: LLVMType) -> LLVMValue: ...
    def const_u_rem(self, rhs: LLVMValue) -> LLVMValue: ...
    def const_xor(self, rhs: LLVMValue) -> LLVMValue: ...
    def const_z_ext(self, to_type: LLVMType) -> LLVMValue: ...
    def const_z_ext_or_bit_cast(self, to_type: LLVMType) -> LLVMValue: ...

    # Additional value operations
    def get_const_opcode(self) -> int: ...
    def get_element_as_constant(self, index: int) -> LLVMValue: ...
    def get_f_cmp_predicate(self) -> int: ...
    def get_i_cmp_predicate(self) -> int: ...
    # Type checking methods (is_a_* methods)
    def is_a_argument(self) -> LLVMValue | None: ...
    def is_a_basic_block(self) -> LLVMValue | None: ...
    def is_a_block_address(self) -> LLVMValue | None: ...
    def is_a_constant(self) -> LLVMValue | None: ...
    def is_a_constant_aggregate_zero(self) -> LLVMValue | None: ...
    def is_a_constant_array(self) -> LLVMValue | None: ...
    def is_a_constant_data_array(self) -> LLVMValue | None: ...
    def is_a_constant_data_sequential(self) -> LLVMValue | None: ...
    def is_a_constant_data_vector(self) -> LLVMValue | None: ...
    def is_a_constant_expr(self) -> LLVMValue | None: ...
    def is_a_constant_fp(self) -> LLVMValue | None: ...
    def is_a_constant_int(self) -> LLVMValue | None: ...
    def is_a_constant_pointer_null(self) -> LLVMValue | None: ...
    def is_a_constant_struct(self) -> LLVMValue | None: ...
    def is_a_constant_vector(self) -> LLVMValue | None: ...
    def is_a_function(self) -> LLVMValue | None: ...
    def is_a_global_alias(self) -> LLVMValue | None: ...
    def is_a_global_object(self) -> LLVMValue | None: ...
    def is_a_global(self) -> LLVMValue | None: ...
    def is_a_global_variable(self) -> LLVMValue | None: ...
    def is_a_inline_asm(self) -> LLVMValue | None: ...
    def is_amd_node(self) -> LLVMValue | None: ...
    def is_amd_string(self) -> LLVMValue | None: ...
    def is_a_undef(self) -> LLVMValue | None: ...
    def is_a_user(self) -> LLVMValue | None: ...

    # Boolean properties
    def is_conditional(self) -> bool: ...
    def is_constant(self) -> bool: ...
    def is_constant_string(self) -> bool: ...
    def is_declaration(self) -> bool: ...
    def is_null(self) -> bool: ...
    def is_undef(self) -> bool: ...

    # Properties
    attribute: int
    const_opcode: int
    f_cmp_predicate: int
    first_use: LLVMUse | None
    global_parent: LLVMModule
    i_cmp_predicate: int
    md_node_num_operands: int
    num_operands: int
    name: bytes
    unnamed_addr: bool

# class TargetLibraryInfotData:
#     def __new__(cls, value=None): ...
#     ptr: Incomplete
#     def __init__(self, value=None) -> None: ...
#     def __hash__(self): ...
#     def __eq__(self, other): ...
#     def in_ptr(self): ...
#     def out_ptr(self): ...
#     def add_target_library_info(self, arg0): ...

class LLVMType:
    # def __new__(cls, value=None) -> LLVMType: ...
    # ptr: Incomplete
    # def __init__(self, value=None) -> None: ...
    # def __hash__(self) -> int: ...
    # def __eq__(self, other) -> bool: ...
    # def in_ptr(self) -> Incomplete: ...
    # def out_ptr(self) -> Incomplete: ...

    # Type information and properties
    def get_context(self) -> LLVMContext: ...
    def get_kind(self) -> int: ...
    def dump(self) -> None: ...
    def print_type_to_string(self) -> bytes: ...
    def is_sized(self) -> bool: ...

    # Type size and alignment
    def align_of(self) -> LLVMValue: ...
    def size_of(self) -> LLVMValue: ...

    # Type construction methods
    def array(self, count: int) -> LLVMType: ...
    def pointer(self, address_space: int) -> LLVMType: ...
    def vector(self, count: int) -> LLVMType: ...
    def function(self, param_types: list[LLVMType], is_var_arg: bool) -> LLVMType: ...

    # Array type methods
    def get_array_length(self) -> int: ...
    def get_element(self) -> LLVMType: ...

    # Function type methods
    def count_param_types(self) -> int: ...
    def get_param_types(self, dest: list[LLVMType]) -> None: ...
    def get_return(self) -> LLVMType: ...
    def is_function_var_arg(self) -> bool: ...

    # Struct type methods
    def count_struct_element_types(self) -> int: ...
    def get_struct_element_types(self, dest: list[LLVMType]) -> None: ...
    def get_struct_name(self) -> bytes: ...
    def is_opaque_struct(self) -> bool: ...
    def is_packed_struct(self) -> bool: ...
    def struct_set_body(self, element_types: list[LLVMType], packed: bool) -> None: ...

    # Pointer type methods
    def get_pointer_address_space(self) -> int: ...

    # Vector type methods
    def get_vector_size(self) -> int: ...

    # Integer type methods
    def get_int_type_width(self) -> int: ...

    # Constant creation methods
    def const_null(self) -> LLVMValue: ...
    def const_all_ones(self) -> LLVMValue: ...
    def const_pointer_null(self) -> LLVMValue: ...
    def get_undef(self) -> LLVMValue: ...
    def const_int(self, value: int, sign_extend: bool) -> LLVMValue: ...
    def const_int_of_arbitrary_precision(self, words: list[int]) -> LLVMValue: ...
    def const_int_of_string(self, text: str, radix: int) -> LLVMValue: ...
    def const_int_of_string_and_size(
        self, text: str, length: int, radix: int
    ) -> LLVMValue: ...
    def const_real(self, value: float) -> LLVMValue: ...
    def const_real_of_string(self, text: str) -> LLVMValue: ...
    def const_real_of_string_and_size(self, text: str, length: int) -> LLVMValue: ...
    def const_array(self, values: list[LLVMValue]) -> LLVMValue: ...
    def const_named_struct(self, values: list[LLVMValue]) -> LLVMValue: ...
    def const_inline_asm(
        self,
        asm_string: str,
        constraints: str,
        has_side_effects: bool,
        is_align_stack: bool,
    ) -> LLVMValue: ...

    # Generic value creation (for execution engine)
    def create_generic_value_of_int(
        self, value: int, is_signed: bool
    ) -> Incomplete: ...
    def create_generic_value_of_float(self, value: float) -> Incomplete: ...
    def generic_value_to_float(self, generic_value: Incomplete) -> float: ...

    # Properties
    context: LLVMContext
    kind: int
    array_length: int
    element: LLVMType
    int_type_width: int
    pointer_address_space: int
    return_: LLVMType
    struct_name: bytes
    undef: LLVMValue
    vector_size: int

class LLVMContext:
    # def __new__(cls, value=None) -> LLVMContext: ...
    # ptr: Incomplete
    # def __init__(self, value=None) -> None: ...
    # def __hash__(self) -> int: ...
    # def __eq__(self, other) -> bool: ...
    # def in_ptr(self) -> Incomplete: ...
    # def out_ptr(self) -> Incomplete: ...

    # Context management
    def dispose(self) -> None: ...
    def set_diagnostic_handler(
        self, handler: Incomplete, diag_context: Incomplete
    ) -> None: ...
    def set_yield_callback(
        self, callback: Incomplete, opaque_handle: Incomplete
    ) -> None: ...

    # Builder creation
    def create_builder(self) -> Incomplete: ...

    # Basic block operations
    def append_basic_block(
        self, function: LLVMFunction, name: str
    ) -> LLVMBasicBlock: ...
    def insert_basic_block(
        self, insert_before: LLVMBasicBlock, name: str
    ) -> LLVMBasicBlock: ...

    # Integer types
    def int1_type(self) -> LLVMType: ...
    def int8_type(self) -> LLVMType: ...
    def int16_type(self) -> LLVMType: ...
    def int32_type(self) -> LLVMType: ...
    def int64_type(self) -> LLVMType: ...
    def int_type(self, num_bits: int) -> LLVMType: ...
    def int_ptr_type(self, target_data: Incomplete) -> LLVMType: ...
    def int_ptr_type_for_as(
        self, target_data: Incomplete, address_space: int
    ) -> LLVMType: ...

    # Floating point types
    def half_type(self) -> LLVMType: ...
    def float_type(self) -> LLVMType: ...
    def double_type(self) -> LLVMType: ...
    def x86fp80_type(self) -> LLVMType: ...
    def fp128_type(self) -> LLVMType: ...
    def ppcfp128_type(self) -> LLVMType: ...

    # Other types
    def void_type(self) -> LLVMType: ...
    def label_type(self) -> LLVMType: ...
    def x86mmx_type(self) -> LLVMType: ...

    # Struct types
    def struct_type(self, element_types: list[LLVMType], packed: bool) -> LLVMType: ...
    def struct_create_named(self, name: str) -> LLVMType: ...

    # Constant creation
    def const_string(
        self, string: str, length: int, dont_null_terminate: bool
    ) -> LLVMValue: ...
    def const_struct(self, values: list[LLVMValue], packed: bool) -> LLVMValue: ...

    # Metadata operations
    def get_md_kind_id(self, name: str, length: int) -> int: ...
    def md_string(self, string: str, length: int) -> LLVMValue: ...
    def md_node(self, values: list[LLVMValue]) -> LLVMValue: ...

    # Module parsing and creation
    def get_bitcode_module(self, mem_buf: Incomplete) -> LLVMModule | None: ...
    def get_bitcode_module_provider(self, mem_buf: Incomplete) -> Incomplete: ...
    def parse_bitcode(self, mem_buf: Incomplete) -> LLVMModule | None: ...
    def parse_ir(self, mem_buf: Incomplete) -> LLVMModule | None: ...

class LLVMBasicBlock:
    # def __new__(cls, value=None) -> LLVMBasicBlock: ...
    # ptr: Incomplete
    # def __init__(self, value=None) -> None: ...
    # def __hash__(self) -> int: ...
    # def __eq__(self, other) -> bool: ...
    # def in_ptr(self) -> Incomplete: ...
    # def out_ptr(self) -> Incomplete: ...

    # Basic block operations
    def delete(self) -> None: ...
    def remove_basic_block_from_parent(self) -> None: ...
    def move_basic_block_after(self, move_pos: LLVMBasicBlock) -> None: ...
    def move_basic_block_before(self, move_pos: LLVMBasicBlock) -> None: ...

    # Value conversion
    def as_value(self) -> LLVMValue: ...

    # Parent function access
    def get_parent(self) -> LLVMFunction: ...

    # Instruction access and navigation
    def get_first_instruction(self) -> LLVMInstruction | None: ...
    def get_last_instruction(self) -> LLVMInstruction | None: ...
    def get_terminator(self) -> LLVMInstruction | None: ...
    def iter_instructions(self) -> Generator[LLVMInstruction, None, None]: ...

    # Basic block navigation
    def get_next(self) -> LLVMBasicBlock | None: ...
    def get_previous(self) -> LLVMBasicBlock | None: ...

    # Instruction insertion
    def insert(self, instruction: LLVMInstruction) -> None: ...

    # Properties
    parent: LLVMFunction
    terminator: LLVMInstruction | None
    first_instruction: LLVMInstruction | None
    last_instruction: LLVMInstruction | None
    next: LLVMBasicBlock | None
    previous: LLVMBasicBlock | None

# class Builder:
#     def __new__(cls, value=None): ...
#     ptr: Incomplete
#     def __init__(self, value=None) -> None: ...
#     def __hash__(self): ...
#     def __eq__(self, other): ...
#     def in_ptr(self): ...
#     def out_ptr(self): ...
#     def build_a_shr(self, arg0, arg1, arg2): ...
#     def build_add(self, arg0, arg1, arg2): ...
#     def build_addr_space_cast(self, arg0, arg1, arg2): ...
#     def build_aggregate_ret(self, arg0): ...
#     def build_alloca(self, arg0, arg1): ...
#     def build_and(self, arg0, arg1, arg2): ...
#     def build_array_alloca(self, arg0, arg1, arg2): ...
#     def build_array_malloc(self, arg0, arg1, arg2): ...
#     def build_atomic_rmw(self, arg0, arg1, arg2, arg3, arg4): ...
#     def build_bin_op(self, arg0, arg1, arg2, arg3): ...
#     def build_bit_cast(self, arg0, arg1, arg2): ...
#     def build_br(self, arg0): ...
#     def build_call(self, arg0, arg1, arg3): ...
#     def build_cast(self, arg0, arg1, arg2, arg3): ...
#     def build_cond_br(self, arg0, arg1, arg2): ...
#     def build_exact_s_div(self, arg0, arg1, arg2): ...
#     def build_extract_element(self, arg0, arg1, arg2): ...
#     def build_extract_value(self, arg0, arg1, arg2): ...
#     def build_f_add(self, arg0, arg1, arg2): ...
#     def build_f_cmp(self, arg0, arg1, arg2, arg3): ...
#     def build_f_div(self, arg0, arg1, arg2): ...
#     def build_f_mul(self, arg0, arg1, arg2): ...
#     def build_f_neg(self, arg0, arg1): ...
#     def build_fp_cast(self, arg0, arg1, arg2): ...
#     def build_fp_ext(self, arg0, arg1, arg2): ...
#     def build_fp_to_si(self, arg0, arg1, arg2): ...
#     def build_fp_to_ui(self, arg0, arg1, arg2): ...
#     def build_fp_trunc(self, arg0, arg1, arg2): ...
#     def build_f_rem(self, arg0, arg1, arg2): ...
#     def build_f_sub(self, arg0, arg1, arg2): ...
#     def build_fence(self, arg0, arg1, arg2): ...
#     def build_free(self, arg0): ...
#     def build_gep(self, arg0, arg1, arg3): ...
#     def build_global_string(self, arg0, arg1): ...
#     def build_global_string_ptr(self, arg0, arg1): ...
#     def build_i_cmp(self, arg0, arg1, arg2, arg3): ...
#     def build_in_bounds_gep(self, arg0, arg1, arg3): ...
#     def build_indirect_br(self, arg0, arg1): ...
#     def build_insert_element(self, arg0, arg1, arg2, arg3): ...
#     def build_insert_value(self, arg0, arg1, arg2, arg3): ...
#     def build_int_cast(self, arg0, arg1, arg2): ...
#     def build_int_to_ptr(self, arg0, arg1, arg2): ...
#     def build_invoke(self, arg0, arg1, arg3, arg4, arg5): ...
#     def build_is_not_null(self, arg0, arg1): ...
#     def build_is_null(self, arg0, arg1): ...
#     def build_l_shr(self, arg0, arg1, arg2): ...
#     def build_landing_pad(self, arg0, arg1, arg2, arg3): ...
#     def build_load(self, arg0, arg1): ...
#     def build_malloc(self, arg0, arg1): ...
#     def build_mul(self, arg0, arg1, arg2): ...
#     def build_nsw_add(self, arg0, arg1, arg2): ...
#     def build_nsw_mul(self, arg0, arg1, arg2): ...
#     def build_nsw_neg(self, arg0, arg1): ...
#     def build_nsw_sub(self, arg0, arg1, arg2): ...
#     def build_nuw_add(self, arg0, arg1, arg2): ...
#     def build_nuw_mul(self, arg0, arg1, arg2): ...
#     def build_nuw_neg(self, arg0, arg1): ...
#     def build_nuw_sub(self, arg0, arg1, arg2): ...
#     def build_neg(self, arg0, arg1): ...
#     def build_not(self, arg0, arg1): ...
#     def build_or(self, arg0, arg1, arg2): ...
#     def build_phi(self, arg0, arg1): ...
#     def build_pointer_cast(self, arg0, arg1, arg2): ...
#     def build_ptr_diff(self, arg0, arg1, arg2): ...
#     def build_ptr_to_int(self, arg0, arg1, arg2): ...
#     def build_resume(self, arg0): ...
#     def build_ret(self, arg0): ...
#     def build_ret_void(self): ...
#     def build_s_div(self, arg0, arg1, arg2): ...
#     def build_s_ext(self, arg0, arg1, arg2): ...
#     def build_s_ext_or_bit_cast(self, arg0, arg1, arg2): ...
#     def build_si_to_fp(self, arg0, arg1, arg2): ...
#     def build_s_rem(self, arg0, arg1, arg2): ...
#     def build_select(self, arg0, arg1, arg2, arg3): ...
#     def build_shl(self, arg0, arg1, arg2): ...
#     def build_shuffle_vector(self, arg0, arg1, arg2, arg3): ...
#     def build_store(self, arg0, arg1): ...
#     def build_struct_gep(self, arg0, arg1, arg2): ...
#     def build_sub(self, arg0, arg1, arg2): ...
#     def build_switch(self, arg0, arg1, arg2): ...
#     def build_trunc(self, arg0, arg1, arg2): ...
#     def build_trunc_or_bit_cast(self, arg0, arg1, arg2): ...
#     def build_u_div(self, arg0, arg1, arg2): ...
#     def build_ui_to_fp(self, arg0, arg1, arg2): ...
#     def build_u_rem(self, arg0, arg1, arg2): ...
#     def build_unreachable(self): ...
#     def build_va_arg(self, arg0, arg1, arg2): ...
#     def build_xor(self, arg0, arg1, arg2): ...
#     def build_z_ext(self, arg0, arg1, arg2): ...
#     def build_z_ext_or_bit_cast(self, arg0, arg1, arg2): ...
#     def clear_insertion_position(self): ...
#     def dispose(self): ...
#     def get_current_debug_location(self): ...
#     def get_insert_block(self): ...
#     def insert_into(self, arg0): ...
#     def insert_into_builder_with_name(self, arg0, arg1): ...
#     def position(self, arg0, arg1): ...
#     def position_builder_at_end(self, arg0): ...
#     def position_builder_before(self, arg0): ...
#     def set_current_debug_location(self, arg0): ...
#     def set_inst_debug_location(self, arg0): ...
#     current_debug_location: Incomplete
#     insert_block: Incomplete
#     inst_debug_location: Incomplete

class LLVMModuleProvider: ...

#     def __new__(cls, value=None): ...
#     ptr: Incomplete
#     def __init__(self, value=None) -> None: ...
#     def __hash__(self): ...
#     def __eq__(self, other): ...
#     def in_ptr(self): ...
#     def out_ptr(self): ...
#     def create_function_pass_manager(self): ...
#     def dispose(self): ...

# class Target:
#     def __new__(cls, value=None): ...
#     ptr: Incomplete
#     def __init__(self, value=None) -> None: ...
#     def __hash__(self): ...
#     def __eq__(self, other): ...
#     def in_ptr(self): ...
#     def out_ptr(self): ...
#     def create_target_machine(self, arg0, arg1, arg2, arg3, arg4, arg5): ...
#     def get_next(self): ...
#     def get_description(self): ...
#     def get_name(self): ...
#     def has_asm_backend(self): ...
#     def has_jit(self): ...
#     def has_target_machine(self): ...
#     next: Incomplete
#     description: Incomplete
#     name: Incomplete

class LLVMMemoryBuffer: ...

#     def __new__(cls, value=None): ...
#     ptr: Incomplete
#     def __init__(self, value=None) -> None: ...
#     def __hash__(self): ...
#     def __eq__(self, other): ...
#     def in_ptr(self): ...
#     def out_ptr(self): ...
#     def dispose(self): ...
#     def get_buffer_size(self): ...
#     def get_buffer_start(self): ...
#     def create_object_file(self): ...
#     def get_bitcode_module(self): ...
#     def get_bitcode_module_provider(self): ...
#     def parse_bitcode(self): ...
#     buffer_size: Incomplete
#     buffer_start: Incomplete

class LLVMPassManager: ...

#     def __new__(cls, value=None): ...
#     ptr: Incomplete
#     def __init__(self, value=None) -> None: ...
#     def __hash__(self): ...
#     def __eq__(self, other): ...
#     def in_ptr(self): ...
#     def out_ptr(self): ...
#     def dispose(self): ...
#     def finalize_function(self): ...
#     def initialize_function(self): ...
#     def run_function(self, arg0): ...
#     def run(self, arg0): ...
#     def add_aggressive_dce_pass(self): ...
#     def add_alignment_from_assumptions_pass(self): ...
#     def add_basic_alias_analysis_pass(self): ...
#     def add_cfg_simplification_pass(self): ...
#     def add_constant_propagation_pass(self): ...
#     def add_correlated_value_propagation_pass(self): ...
#     def add_dead_store_elimination_pass(self): ...
#     def add_demote_memory_to_register_pass(self): ...
#     def add_early_cse_pass(self): ...
#     def add_gvn_pass(self): ...
#     def add_ind_var_simplify_pass(self): ...
#     def add_instruction_combining_pass(self): ...
#     def add_jump_threading_pass(self): ...
#     def add_licm_pass(self): ...
#     def add_loop_deletion_pass(self): ...
#     def add_loop_idiom_pass(self): ...
#     def add_loop_reroll_pass(self): ...
#     def add_loop_rotate_pass(self): ...
#     def add_loop_unroll_pass(self): ...
#     def add_loop_unswitch_pass(self): ...
#     def add_lower_expect_intrinsic_pass(self): ...
#     def add_lower_switch_pass(self): ...
#     def add_mem_cpy_opt_pass(self): ...
#     def add_merged_load_store_motion_pass(self): ...
#     def add_partially_inline_lib_calls_pass(self): ...
#     def add_promote_memory_to_register_pass(self): ...
#     def add_reassociate_pass(self): ...
#     def add_sccp_pass(self): ...
#     def add_scalar_repl_aggregates_pass(self): ...
#     def add_scalar_repl_aggregates_pass_ssa(self): ...
#     def add_scalar_repl_aggregates_pass_with_threshold(self, arg0): ...
#     def add_scalarizer_pass(self): ...
#     def add_scoped_no_alias_aa_pass(self): ...
#     def add_simplify_lib_calls_pass(self): ...
#     def add_tail_call_elimination_pass(self): ...
#     def add_type_based_alias_analysis_pass(self): ...
#     def add_verifier_pass(self): ...
#     def add_bb_vectorize_pass(self): ...
#     def add_loop_vectorize_pass(self): ...
#     def add_slp_vectorize_pass(self): ...
#     def add_always_inliner_pass(self): ...
#     def add_argument_promotion_pass(self): ...
#     def add_constant_merge_pass(self): ...
#     def add_dead_arg_elimination_pass(self): ...
#     def add_function_attrs_pass(self): ...
#     def add_function_inlining_pass(self): ...
#     def add_global_dce_pass(self): ...
#     def add_global_optimizer_pass(self): ...
#     def add_ip_constant_propagation_pass(self): ...
#     def add_ipsccp_pass(self): ...
#     def add_internalize_pass(self, arg0): ...
#     def add_prune_eh_pass(self): ...
#     def add_strip_dead_prototypes_pass(self): ...
#     def add_strip_symbols_pass(self): ...

# class DiagnosticInfo:
#     def __new__(cls, value=None): ...
#     ptr: Incomplete
#     def __init__(self, value=None) -> None: ...
#     def __hash__(self): ...
#     def __eq__(self, other): ...
#     def in_ptr(self): ...
#     def out_ptr(self): ...
#     def get_diag_info_description(self): ...
#     def get_diag_info_severity(self): ...
#     diag_info_description: Incomplete
#     diag_info_severity: Incomplete

class LLVMUse:
    # def __new__(cls, value=None) -> LLVMUse: ...
    # ptr: Incomplete
    # def __init__(self, value=None) -> None: ...
    # def __hash__(self) -> int: ...
    # def __eq__(self, other) -> bool: ...
    # def in_ptr(self) -> Incomplete: ...
    # def out_ptr(self) -> Incomplete: ...

    # Use chain navigation
    def get_next(self) -> LLVMUse | None: ...

    # Use information
    def get_used_value(self) -> LLVMValue: ...
    def get_user(self) -> LLVMValue: ...

    # Properties
    next: LLVMUse | None
    used_value: LLVMValue
    user: LLVMValue

# class PassRegistry:
#     def __new__(cls, value=None): ...
#     ptr: Incomplete
#     def __init__(self, value=None) -> None: ...
#     def __hash__(self): ...
#     def __eq__(self, other): ...
#     def in_ptr(self): ...
#     def out_ptr(self): ...
#     def initialize_analysis(self): ...
#     def initialize_core(self): ...
#     def initialize_target(self): ...
#     def initialize_code_gen(self): ...
#     def initialize_ipa(self): ...
#     def initialize_inst_combine(self): ...
#     def initialize_scalar_opts(self): ...
#     def initialize_transform_utils(self): ...
#     def initialize_vectorization(self): ...
#     def initialize_ipo(self): ...
#     def initialize_obj_carc_opts(self): ...
#     def initialize_instrumentation(self): ...

# class ObjectFile:
#     def __new__(cls, value=None): ...
#     ptr: Incomplete
#     def __init__(self, value=None) -> None: ...
#     def __hash__(self): ...
#     def __eq__(self, other): ...
#     def in_ptr(self): ...
#     def out_ptr(self): ...
#     def dispose(self): ...
#     def get_sections(self): ...
#     def get_symbols(self): ...
#     def is_section_iterator_at_end(self, arg0): ...
#     def is_symbol_iterator_at_end(self, arg0): ...
#     sections: Incomplete
#     symbols: Incomplete

# class RelocationIterator:
#     def __new__(cls, value=None): ...
#     ptr: Incomplete
#     def __init__(self, value=None) -> None: ...
#     def __hash__(self): ...
#     def __eq__(self, other): ...
#     def in_ptr(self): ...
#     def out_ptr(self): ...
#     def dispose(self): ...
#     def get_relocation_address(self): ...
#     def get_relocation_offset(self): ...
#     def get_relocation_symbol(self): ...
#     def get_relocation_type(self): ...
#     def get_relocation_type_name(self): ...
#     def get_relocation_value_string(self): ...
#     def move_to_next_relocation(self): ...
#     relocation_address: Incomplete
#     relocation_offset: Incomplete
#     relocation_symbol: Incomplete
#     relocation_type: Incomplete
#     relocation_type_name: Incomplete
#     relocation_value_string: Incomplete

# class SectionIterator:
#     def __new__(cls, value=None): ...
#     ptr: Incomplete
#     def __init__(self, value=None) -> None: ...
#     def __hash__(self): ...
#     def __eq__(self, other): ...
#     def in_ptr(self): ...
#     def out_ptr(self): ...
#     def dispose(self): ...
#     def get_relocations(self): ...
#     def get_section_address(self): ...
#     def get_section_contains_symbol(self, arg0): ...
#     def get_section_contents(self): ...
#     def get_section_name(self): ...
#     def get_section_size(self): ...
#     def is_relocation_iterator_at_end(self, arg0): ...
#     def move_to_containing_section(self, arg0): ...
#     def move_to_next_section(self): ...
#     relocations: Incomplete
#     section_address: Incomplete
#     section_contents: Incomplete
#     section_name: Incomplete
#     section_size: Incomplete

# class SymbolIterator:
#     def __new__(cls, value=None): ...
#     ptr: Incomplete
#     def __init__(self, value=None) -> None: ...
#     def __hash__(self): ...
#     def __eq__(self, other): ...
#     def in_ptr(self): ...
#     def out_ptr(self): ...
#     def dispose(self): ...
#     def get_symbol_address(self): ...
#     def get_symbol_name(self): ...
#     def get_symbol_size(self): ...
#     def move_to_next_symbol(self): ...
#     symbol_address: Incomplete
#     symbol_name: Incomplete
#     symbol_size: Incomplete

# class ExecutionEngine:
#     def __new__(cls, value=None): ...
#     ptr: Incomplete
#     def __init__(self, value=None) -> None: ...
#     def __hash__(self): ...
#     def __eq__(self, other): ...
#     def in_ptr(self): ...
#     def out_ptr(self): ...
#     def add_global_mapping(self, arg0, arg1): ...
#     def add_module(self, arg0): ...
#     def add_module_provider(self, arg0): ...
#     def dispose(self): ...
#     def find_function(self, arg0): ...
#     def free_machine_code_for_function(self, arg0): ...
#     def get_target_data(self): ...
#     def get_target_machine(self): ...
#     def get_function_address(self, arg0): ...
#     def get_global_value_address(self, arg0): ...
#     def get_pointer_to_global(self, arg0): ...
#     def recompile_and_relink_function(self, arg0): ...
#     def remove_module(self, arg0): ...
#     def remove_module_provider(self, arg0): ...
#     def run_function(self, arg0, arg1, arg2): ...
#     def run_function_as_main(self, arg0, arg1, arg2, arg3): ...
#     def run_static_constructors(self): ...
#     def run_static_destructors(self): ...
#     target_data: Incomplete
#     target_machine: Incomplete

# class GenericValue:
#     def __new__(cls, value=None): ...
#     ptr: Incomplete
#     def __init__(self, value=None) -> None: ...
#     def __hash__(self): ...
#     def __eq__(self, other): ...
#     def in_ptr(self): ...
#     def out_ptr(self): ...
#     def dispose(self): ...
#     def int_width(self): ...
#     def to_int(self, arg0): ...
#     def to_pointer(self): ...

# class MCJITMemoryManager:
#     def __new__(cls, value=None): ...
#     ptr: Incomplete
#     def __init__(self, value=None) -> None: ...
#     def __hash__(self): ...
#     def __eq__(self, other): ...
#     def in_ptr(self): ...
#     def out_ptr(self): ...
#     def dispose(self): ...

# class MCJITCompilerOptions:
#     def __new__(cls, value=None): ...
#     ptr: Incomplete
#     def __init__(self, value=None) -> None: ...
#     def __hash__(self): ...
#     def __eq__(self, other): ...
#     def in_ptr(self): ...
#     def out_ptr(self): ...
#     def initialize(self, arg0): ...

# class PassManagerBuilder:
#     def __new__(cls, value=None): ...
#     ptr: Incomplete
#     def __init__(self, value=None) -> None: ...
#     def __hash__(self): ...
#     def __eq__(self, other): ...
#     def in_ptr(self): ...
#     def out_ptr(self): ...
#     def dispose(self): ...
#     def populate_function_pass_manager(self, arg0): ...
#     def populate_lto_pass_manager(self, arg0, arg1, arg2): ...
#     def populate_module_pass_manager(self, arg0): ...
#     def set_disable_simplify_lib_calls(self, arg0): ...
#     def set_disable_unit_at_a_time(self, arg0): ...
#     def set_disable_unroll_loops(self, arg0): ...
#     def set_opt_level(self, arg0): ...
#     def set_size_level(self, arg0): ...
#     def use_inliner_with_threshold(self, arg0): ...
#     disable_simplify_lib_calls: Incomplete
#     disable_unit_at_a_time: Incomplete
#     disable_unroll_loops: Incomplete
#     opt_level: Incomplete
#     size_level: Incomplete

# Top-level LLVM functions

class LLVMCPy:
    def __init__(self, llvm_config: str | None = None): ...

    # String encoding utility
    def encode_string(self, input_: str) -> bytes: ...

    # Constant creation functions
    def const_f_cmp(
        self, predicate: int, lhs: LLVMValue, rhs: LLVMValue
    ) -> LLVMValue: ...
    def const_i_cmp(
        self, predicate: int, lhs: LLVMValue, rhs: LLVMValue
    ) -> LLVMValue: ...
    def const_string(
        self, string: str, length: int, dont_null_terminate: bool
    ) -> LLVMValue: ...
    def const_struct(self, values: list[LLVMValue], packed: bool) -> LLVMValue: ...
    def const_vector(self, values: list[LLVMValue]) -> LLVMValue: ...

    # Context and builder creation
    def context_create(self) -> LLVMContext: ...
    def get_global_context(self) -> LLVMContext: ...
    def create_builder(self) -> Incomplete: ...

    # Memory buffer operations
    def create_memory_buffer_with_contents_of_file(self, path: str) -> Incomplete: ...
    def create_memory_buffer_with_memory_range(
        self,
        input_data: bytes,
        input_data_length: int,
        buffer_name: str,
        requires_null_terminator: bool,
    ) -> Incomplete: ...
    def create_memory_buffer_with_memory_range_copy(
        self, input_data: bytes, input_data_length: int, buffer_name: str
    ) -> Incomplete: ...
    def create_memory_buffer_with_stdin(self) -> Incomplete: ...

    # Message handling
    def create_message(self, message: str) -> Incomplete: ...
    def dispose_message(self, message: Incomplete) -> None: ...

    # Pass management
    def create_pass_manager(self) -> Incomplete: ...
    def get_global_pass_registry(self) -> Incomplete: ...

    # Target data and targets
    def create_target_data(self, string_rep: str) -> Incomplete: ...
    def get_default_target_triple(self) -> str: ...
    def get_first_target(self) -> Incomplete: ...
    def get_target_from_name(self, name: str) -> Incomplete: ...
    def get_target_from_triple(self, triple: str) -> Incomplete: ...

    # Global integer types (in global context)
    def int1_type(self) -> LLVMType: ...
    def int8_type(self) -> LLVMType: ...
    def int16_type(self) -> LLVMType: ...
    def int32_type(self) -> LLVMType: ...
    def int64_type(self) -> LLVMType: ...
    def int_type(self, num_bits: int) -> LLVMType: ...

    # Global floating-point types (in global context)
    def half_type(self) -> LLVMType: ...
    def float_type(self) -> LLVMType: ...
    def double_type(self) -> LLVMType: ...
    def x86fp80_type(self) -> LLVMType: ...
    def fp128_type(self) -> LLVMType: ...
    def ppcfp128_type(self) -> LLVMType: ...

    # Other global types
    def void_type(self) -> LLVMType: ...
    def label_type(self) -> LLVMType: ...
    def x86mmx_type(self) -> LLVMType: ...

    # Global struct type creation
    def struct_type(self, element_types: list[LLVMType], packed: bool) -> LLVMType: ...

    # Metadata operations
    def get_md_kind_id(self, name: str, length: int) -> int: ...
    def md_string(self, string: str, length: int) -> LLVMValue: ...
    def md_node(self, values: list[LLVMValue]) -> LLVMValue: ...

    # Module creation
    def module_create_with_name(self, module_id: str) -> LLVMModule: ...
    def module_create_with_name_in_context(
        self, module_id: str, context: LLVMContext
    ) -> LLVMModule: ...

    # LLVM system management
    def enable_pretty_stack_trace(self) -> None: ...
    def install_fatal_error_handler(self, handler: Incomplete) -> None: ...
    def reset_fatal_error_handler(self) -> None: ...
    def shutdown(self) -> None: ...

    # Threading support
    def is_multithreaded(self) -> bool: ...
    def start_multithreaded(self) -> bool: ...
    def stop_multithreaded(self) -> None: ...

    # Library loading
    def load_library_permanently(self, filename: str) -> bool: ...

    # Command line parsing
    def parse_command_line_options(
        self, argc: int, argv: list[str], overview: str
    ) -> None: ...

    # def initialize_sparc_asm_printer(): ...
    # def initialize_sparc_target(): ...
    # def initialize_sparc_target_info(): ...
    # def initialize_sparc_target_mc(): ...
    # def initialize_nvptx_asm_printer(): ...
    # def initialize_nvptx_target(): ...
    # def initialize_nvptx_target_info(): ...
    # def initialize_nvptx_target_mc(): ...
    # def create_disasm(arg0, arg1, arg2, arg3, arg4): ...
    # def create_disasm_cpu(arg0, arg1, arg2, arg3, arg4, arg5): ...
    # def create_disasm_cpu_features(arg0, arg1, arg2, arg3, arg4, arg5, arg6): ...
    # def disasm_dispose(arg0): ...
    # def disasm_instruction(arg0, arg1, arg2, arg3, arg4, arg5): ...
    # def initialize_x86_asm_printer(): ...
    # def initialize_x86_target(): ...
    # def initialize_x86_target_info(): ...
    # def initialize_x86_target_mc(): ...
    # def set_disasm_options(arg0, arg1): ...
    # def initialize_hexagon_target_info(): ...
    # def initialize_hexagon_target_mc(): ...
    # def initialize_x_core_asm_printer(): ...
    # def initialize_x_core_target(): ...
    # def initialize_x_core_target_info(): ...
    # def initialize_x_core_target_mc(): ...
    # def create_execution_engine(arg1): ...
    # def create_execution_engine_for_module(arg1): ...
    # def create_generic_value_of_pointer(arg0): ...
    # def create_interpreter(arg1): ...
    # def create_interpreter_for_module(arg1): ...
    # def create_jit_compiler(arg1, arg2): ...
    # def create_jit_compiler_for_module(arg1, arg2): ...
    # def create_mcjit_compiler_for_module(arg1, arg2, arg3): ...
    # def create_simple_mcjit_memory_manager(arg0, arg1, arg2, arg3, arg4): ...
    # def initialize_a_arch64_target_info(): ...
    # def initialize_hexagon_disassembler(): ...
    # def initialize_system_z_asm_parser(): ...
    # def initialize_system_z_target_info(): ...
    # def initialize_system_z_target_mc(): ...
    # def initialize_sparc_asm_parser(): ...
    # def pass_manager_builder_create(): ...
    # def initialize_mips_target_info(): ...
    # def initialize_a_arch64_asm_printer(): ...
    # def initialize_a_arch64_target(): ...
    # def initialize_a_arch64_target_mc(): ...
    # def initialize_power_pc_target_info(): ...
    # def initialize_mips_asm_parser(): ...
    # def initialize_mips_target_mc(): ...
    # def initialize_arm_target_info(): ...
    # def initialize_arm_target_mc(): ...
    # def initialize_x86_disassembler(): ...
    # def initialize_arm_asm_parser(): ...
    # def initialize_power_pc_disassembler(): ...
    # def initialize_hexagon_asm_printer(): ...
    # def initialize_hexagon_target(): ...
    # def initialize_a_arch64_disassembler(): ...
    # def initialize_x_core_disassembler(): ...
    # def link_in_mcjit(): ...
    # def initialize_system_z_disassembler(): ...
    # def initialize_sparc_disassembler(): ...
    # def initialize_a_arch64_asm_parser(): ...
    # def initialize_power_pc_target_mc(): ...
    # def initialize_msp430_asm_printer(): ...
    # def initialize_msp430_target(): ...
    # def initialize_msp430_target_info(): ...
    # def initialize_msp430_target_mc(): ...
    # def initialize_mips_disassembler(): ...
    # def initialize_x86_asm_parser(): ...
    # def initialize_power_pc_asm_printer(): ...
    # def initialize_power_pc_target(): ...
    # def link_in_interpreter(): ...
    # def initialize_system_z_asm_printer(): ...
    # def initialize_system_z_target(): ...
    # def initialize_mips_asm_printer(): ...
    # def initialize_mips_target(): ...
    # def initialize_arm_asm_printer(): ...
    # def initialize_arm_target(): ...
    # def initialize_arm_disassembler(): ...
    # def initialize_power_pc_asm_parser(): ...

    AShr: int
    AbortProcessAction: int
    Add: int
    AddrSpaceCast: int
    Alignment: int
    Alloca: int
    AlwaysInlineAttribute: int
    And: int
    AnyRegCallConv: int
    AppendingLinkage: int
    ArrayTypeKind: int
    AssemblyFile: int
    AtomicCmpXchg: int
    AtomicOrderingAcquire: int
    AtomicOrderingAcquireRelease: int
    AtomicOrderingMonotonic: int
    AtomicOrderingNotAtomic: int
    AtomicOrderingRelease: int
    AtomicOrderingSequentiallyConsistent: int
    AtomicOrderingUnordered: int
    AtomicRMW: int
    AtomicRMWBinOpAdd: int
    AtomicRMWBinOpAnd: int
    AtomicRMWBinOpMax: int
    AtomicRMWBinOpMin: int
    AtomicRMWBinOpNand: int
    AtomicRMWBinOpOr: int
    AtomicRMWBinOpSub: int
    AtomicRMWBinOpUMax: int
    AtomicRMWBinOpUMin: int
    AtomicRMWBinOpXchg: int
    AtomicRMWBinOpXor: int
    AvailableExternallyLinkage: int
    BigEndian: int
    BitCast: int
    Br: int
    ByValAttribute: int
    CCallConv: int
    Call: int
    CodeGenLevelAggressive: int
    CodeGenLevelDefault: int
    CodeGenLevelLess: int
    CodeGenLevelNone: int
    CodeModelDefault: int
    CodeModelJITDefault: int
    CodeModelKernel: int
    CodeModelLarge: int
    CodeModelMedium: int
    CodeModelSmall: int
    ColdCallConv: int
    CommonLinkage: int
    DLLExportLinkage: int
    DLLExportStorageClass: int
    DLLImportLinkage: int
    DLLImportStorageClass: int
    DSError: int
    DSNote: int
    DSRemark: int
    DSWarning: int
    DefaultStorageClass: int
    DefaultVisibility: int
    DoubleTypeKind: int
    ExternalLinkage: int
    ExternalWeakLinkage: int
    ExtractElement: int
    ExtractValue: int
    FAdd: int
    FCmp: int
    FDiv: int
    FMul: int
    FP128TypeKind: int
    FPExt: int
    FPToSI: int
    FPToUI: int
    FPTrunc: int
    FRem: int
    FSub: int
    FastCallConv: int
    Fence: int
    FloatTypeKind: int
    FunctionTypeKind: int
    GeneralDynamicTLSModel: int
    GetElementPtr: int
    GhostLinkage: int
    HalfTypeKind: int
    HiddenVisibility: int
    ICmp: int
    InRegAttribute: int
    IndirectBr: int
    InitialExecTLSModel: int
    InlineHintAttribute: int
    InsertElement: int
    InsertValue: int
    IntEQ: int
    IntNE: int
    IntSGE: int
    IntSGT: int
    IntSLE: int
    IntSLT: int
    IntToPtr: int
    IntUGE: int
    IntUGT: int
    IntULE: int
    IntULT: int
    IntegerTypeKind: int
    InternalLinkage: int
    Invoke: int
    LShr: int
    LabelTypeKind: int
    LandingPad: int
    LandingPadCatch: int
    LandingPadFilter: int
    LinkOnceAnyLinkage: int
    LinkOnceODRAutoHideLinkage: int
    LinkOnceODRLinkage: int
    LinkerDestroySource: int
    LinkerPreserveSource: int
    LinkerPrivateLinkage: int
    LinkerPrivateWeakLinkage: int
    LittleEndian: int
    Load: int
    LocalDynamicTLSModel: int
    LocalExecTLSModel: int
    MetadataTypeKind: int
    Mul: int
    NakedAttribute: int
    NestAttribute: int
    NoAliasAttribute: int
    NoCaptureAttribute: int
    NoImplicitFloatAttribute: int
    NoInlineAttribute: int
    NoRedZoneAttribute: int
    NoReturnAttribute: int
    NoUnwindAttribute: int
    NonLazyBind: int
    NotThreadLocal: int
    OptimizeForSizeAttribute: int
    Or: int
    PHI: int
    PPC_FP128TypeKind: int
    PointerTypeKind: int
    PrintMessageAction: int
    PrivateLinkage: int
    ProtectedVisibility: int
    PtrToInt: int
    ReadNoneAttribute: int
    ReadOnlyAttribute: int
    RealOEQ: int
    RealOGE: int
    RealOGT: int
    RealOLE: int
    RealOLT: int
    RealONE: int
    RealORD: int
    RealPredicateFalse: int
    RealPredicateTrue: int
    RealUEQ: int
    RealUGE: int
    RealUGT: int
    RealULE: int
    RealULT: int
    RealUNE: int
    RealUNO: int
    RelocDefault: int
    RelocDynamicNoPic: int
    RelocPIC: int
    RelocStatic: int
    Resume: int
    Ret: int
    ReturnStatusAction: int
    ReturnsTwice: int
    SDiv: int
    SExt: int
    SExtAttribute: int
    SIToFP: int
    SRem: int
    Select: int
    Shl: int
    ShuffleVector: int
    StackAlignment: int
    StackProtectAttribute: int
    StackProtectReqAttribute: int
    Store: int
    StructRetAttribute: int
    StructTypeKind: int
    Sub: int
    Switch: int
    Trunc: int
    UDiv: int
    UIToFP: int
    URem: int
    UWTable: int
    Unreachable: int
    UserOp1: int
    UserOp2: int
    VAArg: int
    VectorTypeKind: int
    VoidTypeKind: int
    WeakAnyLinkage: int
    WeakODRLinkage: int
    WebKitJSCallConv: int
    X86FastcallCallConv: int
    X86StdcallCallConv: int
    X86_FP80TypeKind: int
    X86_MMXTypeKind: int
    Xor: int
    ZExt: int
    ZExtAttribute: int
    LLVM_LTO_ASM_FAILURE: int
    LLVM_LTO_MODULE_MERGE_FAILURE: int
    LLVM_LTO_NO_TARGET: int
    LLVM_LTO_NO_WORK: int
    LLVM_LTO_NULL_OBJECT: int
    LLVM_LTO_OPT_SUCCESS: int
    LLVM_LTO_READ_FAILURE: int
    LLVM_LTO_READ_SUCCESS: int
    LLVM_LTO_UNKNOWN: int
    LLVM_LTO_WRITE_FAILURE: int
    LTO_CODEGEN_PIC_MODEL_DEFAULT: int
    LTO_CODEGEN_PIC_MODEL_DYNAMIC: int
    LTO_CODEGEN_PIC_MODEL_DYNAMIC_NO_PIC: int
    LTO_CODEGEN_PIC_MODEL_STATIC: int
    LTO_DEBUG_MODEL_DWARF: int
    LTO_DEBUG_MODEL_NONE: int
    LTO_DS_ERROR: int
    LTO_DS_NOTE: int
    LTO_DS_REMARK: int
    LTO_DS_WARNING: int
    LTO_SYMBOL_ALIGNMENT_MASK: int
    LTO_SYMBOL_DEFINITION_MASK: int
    LTO_SYMBOL_DEFINITION_REGULAR: int
    LTO_SYMBOL_DEFINITION_TENTATIVE: int
    LTO_SYMBOL_DEFINITION_UNDEFINED: int
    LTO_SYMBOL_DEFINITION_WEAK: int
    LTO_SYMBOL_DEFINITION_WEAKUNDEF: int
    LTO_SYMBOL_PERMISSIONS_CODE: int
    LTO_SYMBOL_PERMISSIONS_DATA: int
    LTO_SYMBOL_PERMISSIONS_MASK: int
    LTO_SYMBOL_PERMISSIONS_RODATA: int
    LTO_SYMBOL_SCOPE_DEFAULT: int
    LTO_SYMBOL_SCOPE_DEFAULT_CAN_BE_HIDDEN: int
    LTO_SYMBOL_SCOPE_HIDDEN: int
    LTO_SYMBOL_SCOPE_INTERNAL: int
    LTO_SYMBOL_SCOPE_MASK: int
    LTO_SYMBOL_SCOPE_PROTECTED: int
    Attribute: Incomplete
    Opcode: Incomplete
    TypeKind: Incomplete
    Linkage: Incomplete
    Visibility: Incomplete
    DLLStorageClass: Incomplete
    CallConv: Incomplete
    IntPredicate: Incomplete
    RealPredicate: Incomplete
    LandingPadClauseTy: Incomplete
    ThreadLocalMode: Incomplete
    AtomicOrdering: Incomplete
    AtomicRMWBinOp: Incomplete
    DiagnosticSeverity: Incomplete
    VerifierFailureAction: Incomplete
    CodeGenOptLevel: Incomplete
    RelocMode: Incomplete
    CodeModel: Incomplete
    CodeGenFileType: Incomplete
    llvm_lto_status_t: Incomplete
    lto_symbol_attributes: Incomplete
    lto_debug_model: Incomplete
    lto_codegen_model: Incomplete
    lto_codegen_diagnostic_severity_t: Incomplete
    LinkerMode: Incomplete
